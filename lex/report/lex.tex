\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цель работы}

Ознакомится с возможностями программирования лексического разбора на языке Lex.

\section{Знакомство с языком Lex}

\subsection{Удаление пробелов и табуляций в начале строк}

Рассмотрим программу, которая передает в выходной поток все литеры входного потока кроме пробелов и/или табуляций в начале строки.

\lex{ex01}

Подадим программе на вход несколько тестовых примеров:

\inout{ex01}

Из результатов видно, что пробелы и табуляции в начале строки были успешно удалены.

\subsection{Подсчет числа строк}

Рассмотрим программу, выполняющую подсчет числа строк во входящей последовательности.

\lex{ex02}

Подадим программе на вход разные входные последовательности:
\begin{itemize}
	\item Файл, состоящий из пяти строк
	\item Пустой файл
\end{itemize}

\inout{ex02.1}
\inout{ex02.2}

Из результатов видно, что в обоих случаях число строк было посчитано верно.

\subsection{Подсчет и вывод знаковых целых чисел}

Рассмотрим программу, реализующую подсчет последовательностей, которые обозначают знаковые целые числа; каждый раз при обнаружении такой последовательности выводится текущее значение счетчика чисел и текст лексемы

\lex{ex03}

\inout{ex03}

Из результатов видно, что программа успешно распознала во входном потоке все целые числа со знаком и пронумеровала их от 1 до 7.

\subsection{Вывод идентификаторов и беззнаковых целых чисел}

Рассмотрим программу вывода идентификаторов и беззнаковых целых чисел.

\lex{ex04}

\inout{ex04}

Из результатов видно, что программа вывела только цифры и слова, состоящие из букв латинского алфавита, удалив из потока входных символов знаки препинания, знаки чисел и кириллицу. 

\subsection{Подсчет и вывод гистограммы длин слов}

Рассмотрим программу подсчета идентификаторов по длине. Результат выполнения -- гистограмма длин слов в диапазоне от 1 до 40, в виде текста на русском или английском языках.
 
\lex{ex05}

\inout{ex05.1}

\inout{ex05.2}

Из результатов видно, что программа успешно подсчитала и вывела гистограмму длин слов для текстов на русском и английском языках.

\subsection{Вывод строки наискосок при помощи \code{yyless}}

Рассмотрим программу вывода входной строки наискосок при помощи \code{yyless}. Функция \code{yyless(n)} сокращает строку в \code{yytext} до n первых литер, возвращая остаток во входной
поток.

\lex{ex06}

\inout{ex06}

Видно, что программа сначала выводит всю строку, затем правую половину всей строки, затем правую половину от половины строки и т.д. Округление при делении \code{yyless(yyleng/2)} происходит в нижнюю сторону, поэтому, например, если поток содержит 7 входных символов, то во второй строке будет выведено 4 правых символа.

\subsection{Макросы и ввод-вывод низкого уровня с проверкой конца входного потока}

Рассмотрим программу, демонстрирующую использование функций низкоуровневого ввода-вывода:

\begin{itemize}
	\item \code{input()} -- чтение следующей литеры из входного потока (в конце потока считывается \code{null}-литера);
	\item \code{output(c)} -- запись литеры c в выходной поток;
	\item \code{unput(c)} -- запись литеры c во входной поток
\end{itemize}

Функция input используется для поиска конца комментария, заданного в стиле языка C -- \code{/* */}. Также демонстрируются макроопределения 16-ричных цифр \code{H}, десятичных цифр \code{D} и букв \code{L} и их подстановки: \code{\{H}\}, \code{\{D\}} и \code{\{L\}}.

\lex{ex07_2}

\inout{ex07_2}

Видно, что программа успешно выделяла во входном потоке идентификаторы и числа. Тем не менее, программе не удалось справиться с незакрытым комментарием: программа циклилась.

\subsection{Функция \code{unput} и дублирование \code{yytext} и \code{yyleng} при работе с \code{unput}}

Рассмотрим программу, реверсирующую идентификаторы, начинающихся с \code{'@'}, при помощи функции \code{unput}.

\lex{ex08_2}

\inout{ex08_2}

Видно, что порядок букв в словах, начинающихся с символа \code{'@'} был перевернут.

\subsection{Двусмысленный набор правил}

Если при поиске лексемы входная последовательность может быть распознана несколькими шаблонами, то набор правил двусмысленный. В этой ситуации правило выбирается по следующей схеме:

\begin{itemize}
	\item Предпочтение отдается соответствию большей длины;
	\item Если одна и та же последовательность соответствует нескольким правилам, предпочтение отдается тому правилу, которое задано раньше других.
\end{itemize}

Рассмотрим пример, содержащий двусмысленный набор правил.

\lex{ex09}

\inout{ex09}

Видно, что первое правильно было применено только к входному слову \code{read}, потому что при этом в обоих правилах было задействовано одинаковое количество символов, но первое правило было задано раньше. В остальных случаях было применено второе правило.

\subsection{Шаблон для распознавания строки в кавычках}

Для распознавания строки в кавычках будет неверно применить шаблон \code{\%\% '.*' ; \%\%}, потому что в данном случае будет применен принцип предпочтения соответствия наибольшей длины, и, если в строке несколько слов в кавычках, будет выбрана вся строка между первой и последней кавычками.

Рассмотрим программу с верным шаблоном.

\lex{ex11}

\inout{ex11}

Видно что строки в кавычках были удалены из входного потока согласно действию, описанному в шаблоне.

\subsection{Использование переменной состояния}

Рассмотрим пример с использованием переменной состояния. Требуется в каждой строке заменить \code{'magic'} на \code{'first'}, \code{'second'} или \code{'third'} в зависимости от того, какая цифра была в начале строки — 1, 2, или 3.

\lex{ex12}

\inout{ex12}

Видно, что благодаря переменной состояния слово \code{'magic'} было корректно заменено в зависимости от цифры в начале строки.

\subsection{Решение при помощи стартовых условий}

Решим ту же задачу при помощи стартовых условий.

\lex{ex13_2}

\inout{ex13_2}

Видно, что результат совпал с предыдущим решением. Кроме того, была произведена трассировка состояния, благодаря которому можно удобно отследить его изменение на каждом шаге.

\subsection{Подсчет количества <<she>> и <<he>> без учета <<he>> внутри <<she>>}

Анализ вложенных и перекрывающихся последовательностей требует
применения специальных средств.

Рассмотрим пример, который запрограммирован на счет последовательностей \code{'she'} и \code{'he'}. Но эта программа не выявляет экземпляры \code{'he'} внутри \code{'she'}, т.к. после распознавания \code{'she'} эти литеры уходят из входной последовательности.

\lex{ex14_1}

\inout{ex14_1}

Видно, что оба слова были распознаны по два раза.

\subsection{Подсчет всех экземпляров <<she>> и <<he>>}

Исправим шаблон, чтобы учитывались встречания \code{'he'} внутри слова \code{'she'}.

Для выявления вложенной последовательности нужно:
\begin{enumerate}
	\item вернуть принятую последовательность во входной поток;
	\item исключить правило, которым была распознана эта последовательность;
	\item возобновить сопоставление.
\end{enumerate}

Первая фаза этого действия может быть реализована вызовом \code{yyless(0)}, вторая -- при помощи стартовых условий. Но можно задать это действие одной макрокомандой \code{REJECT}. При обнаружении \code{'she'} увеличивается счетчик s, команда REJECT отвергает правило и возвращает \code{'she'} на вход. Затем предпринимается попытка заново сопоставить тот же ввод с оставшимися шаблонами.

\lex{ex14_2}

\inout{ex14_2}

Видно, что теперь последовательность \code{'he'} была распознана 4 раза.

\subsection{Подсчет <<she>> и <<he>> с использованием \code{yyless}}

Для получения аналогичного результата можно заменить \code{REJECT} на \code{yyless(1)}, которая сокращает строку в \code{yytext} до первой литеры, возвращая остаток во входной
поток.

\lex{ex14_3}

\inout{ex14_3}

Результат аналогичен предыдущей реализации.

\newpage

\section{Контрольный вопрос}

Каким должен быть шаблон для выявления: \code{xyz} \code{xxzy} \code{xxyz} \code{xxyzzy}\\ \code{xxxxxxxyzyzzyzyyzzy} и т.д.

\lex{ind}

\inout{ind}

Видно, что были выявлены все заданные последовательности. Были придуманы 5 примеров, на которые шаблон справедливо не среагировал.

\section{Выводы}

В процессе выполнения данной работы:

\begin{itemize}
	\item был изучен синтаксис языка лексического разбора \code{Lex};
	\item продемонстрированы базовые возможности \code{Lex} с помощью готовых программ;
	\item реализована собственная программа, выявляющая во входном потоке определенные последовательности букв.
\end{itemize}

\end{document}
