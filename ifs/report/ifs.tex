\include{settings}

\begin{document}

\include{titlepage}

\tableofcontents
\newpage

\section{Цель работы}

Составить \code{Lex} и \code{yacc}-программу, которая будет осуществлять разбор оператора \code{if} (без \code{else}) языка \code{C} с типом данных -- \code{int}. Условное выражение -- бесскобочное арифметическое выражение, содержащее операторы \code{+ - * /}, где все операции выполняются слева направо. 

\noindent Тело оператора:

\begin{itemize}
	\item или только операторы присваивания вида \code{id =} бесскобочное арифметическое выражение (аналогично условному выражению);
	\item или вложенный оператор \code{if}.
\end{itemize}

\noindent Выходной продукт:

\begin{itemize}
	\item тетрады матрицы синтаксического дерева.
\end{itemize}

\section{Выполнение работы}

Для создания транслятора были разработаны программы на языках \code{Lex} и \code{yacc}. \code{Lex}-программа обрабатывает входные данные и выделяет среди них нужные лексемы:

\begin{itemize}
	\item ключевое слово \code{if};
	\item символ операции (\code{+}, \code{-}, \code{*}, \code{/});
	\item целые числа;
	\item идентификаторы переменных;
	\item пропуск пробельных символов.
\end{itemize}

\lex{ifs}

Программа на языке \code{yacc} содержит правила для обработки последовательности лексем. Приведем грамматики для всех синтаксических конструкций, подлежащих трансляции, в форме Бэкуса --- Наура (БНФ):

\begin{itemize}[leftmargin=0.9em]
	\item \bfn{операторы} <оператор> | <оператор> <операторы>
	\item \bfn{оператор} <ветвление> | <присваивание>
	\item \bfn{ветвление} \code{if} \code{(} <выражение> \code{)} <начало> <операторы> <конец>
	\item \bfn{начало} \code{\{}
	\item \bfn{конец} \code{\}}
	\item \bfn{присваивание} <идентификатор> \code{=} <выражение> \code{;}
	\item \bfn{идентификатор} \code{[A-Za-z\_][A-Za-z0-9\_]+}
	\item \bfn{выражение} <число> | <выражение> <операция> <выражение>
	\item \bfn{число} \code{[0-9]+}
	\item \bfn{операция} \code{+} | \code{-} | \code{*} | \code{/}
\end{itemize}

Кроме того, для формирования имен меток перехода и строк матрицы синтаксического дерева используются переменные-счетчики и стек на основе массива.

\yacc{ifs}

Основная программа \code{zz.c}:

\cc{zz}

Программа генерирует на выходе матрицу синтаксического дерева с элементами ветвления. Таким образом каждая строка на выходе:

\begin{itemize}
	\item или оператор ветвления, схожий с командой условного перехода в ассемблере: \code{JZ T L}, где \code{T} -- число или номер строки матрицы синтаксического дерева, а \code{L} -- метка, по которой необходимо перейти, в случае если \code{T} равно нулю;
	\item или тетрада матрицы синтаксического дерева: \code{T @ A B}, где \code{T} -- номер строки матрицы, \code{@} -- один из арифметических операторов, а \code{A} и \code{B} -- числа или номера строк матрицы, над которыми производится операция. 
\end{itemize}

Подадим на вход различные синтаксически корректные входные данные:

\inout{test1}

\inout{test2}

\inout{test3}

Видно, что разработанная программа успешно транслирует условное выражение в матрицу синтаксического дерева. Протестируем отладочные сообщения, которые должны появляться в случае появления синтаксических ошибок во входных данных:

\inout{test4}

\inout{test5}

Видно, что в первом случае \code{if} содержит пустое условное выражение, а во втором -- отсутствуют обязательные для данной реализации фигурные скобки после условного выражения. Данное ограничение не соответствует языку \code{C}, но в противном случае было бы тяжело сгенерировать метку, по которой необходимо перейти в случае, если условное выражение равно нулю.

\newpage

\section{Выводы}

В процессе выполнения данной работы:

\begin{itemize}
	\item был закреплен на практике навык написания программ на языке лексического разбора \code{Lex} и языке синтаксического анализатора \code{yacc};
	\item реализована собственная программа, позволяющая производить разбор и трансляцию в матрицу синтаксического дерева условного оператора \code{if} языка \code{C}, содержащего в теле оператора присваивания или вложенные операторы \code{if}.
\end{itemize}

\end{document}
